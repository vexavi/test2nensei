<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ボスタイピング（JRPG UI）</title>
  <style>
    :root{
      --bg:#0a0c13;
      --ink:#f3f6ff;
      --muted:#b8c3e6;
      --gold:#d9c27a;
      --wordH: 30;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      background: radial-gradient(900px 520px at 50% 0%, rgba(100,120,255,.16), transparent 60%),
                  radial-gradient(1000px 600px at 10% 100%, rgba(255,140,100,.10), transparent 55%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-monospace, "MS Gothic", "Osaka", "Noto Sans JP", monospace;

      display:flex;
      justify-content:center;
      align-items:center;

      min-height:100dvh;
      padding:
        calc(16px + env(safe-area-inset-top))
        16px
        calc(16px + env(safe-area-inset-bottom))
        16px;

      overflow-x:hidden;
      -webkit-text-size-adjust: 100%;
    }

    .pixel{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .frame{
      width:min(1024px, 100%);
      border:6px solid var(--gold);
      box-shadow: 0 0 0 2px rgba(0,0,0,.45), inset 0 0 0 2px rgba(0,0,0,.45);
      background: rgba(0,0,0,.20);
      touch-action: manipulation;
    }

    .battlefield{
      position:relative;
      height: min(520px, 56vh);
      border-bottom:6px solid var(--gold);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(40,45,70,.55), rgba(10,12,19,.75));
    }

    .bgImg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      opacity: 0.85;
      display:none;
    }
    .bgFallback{
      position:absolute; inset:0;
      background:
        radial-gradient(240px 180px at 20% 20%, rgba(255,210,120,.18), transparent 60%),
        radial-gradient(220px 180px at 70% 30%, rgba(120,160,255,.18), transparent 60%),
        linear-gradient(180deg, rgba(30,35,60,.55), rgba(10,12,19,.75));
    }

    /* Word lane */
    .wordLane{
      position:absolute;
      left: 26px;
      top: 22px;
      bottom: 84px; /* leave space for input bar under the lane */
      width: min(360px, 46%);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(10,10,18,.35);
      overflow:hidden;
    }

    .laneLabel{
      position:absolute;
      left: 36px;
      top: 30px;
      z-index:3;
      background: rgba(0,0,0,.55);
      border:2px solid rgba(255,255,255,.12);
      padding:6px 10px;
      font-size:12px;
      color: var(--muted);
    }

    .overflowBadge{
      position:absolute;
      right: 18px;
      top: 18px;
      z-index:5;
      background: rgba(255,220,120,.95);
      color:#140e00;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.12);
      padding:6px 10px;
      font-weight:900;
      display:none;
    }
    .overflowBadge.show{ display:block; }

    /* Input bar directly under falling words */
    .inputBar{
      position:absolute;
      left: 26px;
      bottom: 22px;
      width: min(360px, 46%);
      height: 52px;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      background: rgba(0,0,0,.32);
      z-index:6;
      display:flex;
      align-items:center;
      padding: 8px 10px;
      gap:10px;
    }
    .promptChar{
      color: var(--gold);
      font-weight:900;
      font-size:16px;
      flex: 0 0 auto;
    }
    .inputBar form{
      display:flex;
      align-items:center;
      gap:10px;
      width:100%;
      height:100%;
      margin:0;
    }
    .inputBar input[type="text"]{
      width:100%;
      background: transparent;
      border:none;
      outline:none;
      color: var(--ink);
      font-size:16px;
      font-family: inherit;
      height: 36px;
      padding: 4px 6px;
    }
    .inputBar input[type="text"]::placeholder{ color: rgba(184,195,230,.65); }

    .word{
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      width: calc(100% - 22px);
      height: calc(var(--wordH) * 1px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:0 10px;

      background: rgba(26,22,48,.85);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 8px 12px rgba(0,0,0,.35);
    }
    .word .prompt{
      font-weight:900;
      letter-spacing:.2px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .word .tag{
      color: var(--muted);
      font-size:12px;
      flex:0 0 auto;
      white-space:nowrap;
    }
    .word.hint .tag{
      color: var(--gold);
      font-weight:900;
    }
    .word.landed{
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      background: rgba(18,16,34,.85);
    }

    /* Boss area */
    .bossWrap{
      position:absolute;
      right: 70px;
      top: 44px;
      bottom: 44px;
      width: min(360px, 42%);
      display:grid;
      place-items:center;
      pointer-events:none;
    }
    .bossInner{
      position:relative;
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
    }
    .bossImg{
      width:100%;
      height:100%;
      object-fit:contain;
      display:none;
      filter: drop-shadow(0 10px 0 rgba(0,0,0,.35));
    }
    .bossFallback{
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: rgba(243,246,255,.85);
      font-weight:900;
      text-align:center;
      padding:12px;
    }

    .stage5Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .stage5Timer.show{ display:block; }

    /* NEW: flashing invulnerable sign under Stage 5 timer */
    .stage5InvSign{
      position:absolute;
      right: 10px;
      top: 106px; /* sits under the timer */
      padding:7px 12px;
      font-size:13px;
      font-weight:900;
      color:#140e00;
      background: rgba(255,220,120,.95);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.12), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
      animation: invBlink .75s steps(2, end) infinite;
    }
    .stage5InvSign.show{ display:block; }
    @keyframes invBlink{
      0%   { filter: brightness(1); transform: translateY(0); opacity: 1; }
      50%  { filter: brightness(1.25); transform: translateY(-1px); opacity: .65; }
      100% { filter: brightness(1); transform: translateY(0); opacity: 1; }
    }

    .bossBubble{
      position:absolute;
      left:50%;
      top: 12px;
      transform: translateX(-50%);
      max-width: 92%;
      padding:8px 10px;
      font-size:13px;
      line-height:1.45;
      color: var(--ink);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      opacity:0;
      display:none;
      z-index:9;
      text-align:center;
    }
    .bossBubble.show{
      display:block;
      animation: bubbleIn .12s ease-out forwards;
    }
    @keyframes bubbleIn{
      from { opacity:0; transform: translateX(-50%) translateY(-6px); }
      to   { opacity:1; transform: translateX(-50%) translateY(0); }
    }
    .bossBubble:after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-10px;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-top:10px solid rgba(0,0,0,.66);
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.35));
    }

    .bossBuffBanner{
      position:absolute;
      right: 10px;
      bottom: 10px;
      padding:6px 10px;
      font-size:12px;
      font-weight:900;
      color:#140e00;
      background: rgba(255,220,120,.95);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.12), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:7;
      letter-spacing:.2px;
    }
    .bossBuffBanner.show{
      display:block;
      animation: buffPulse .9s ease-in-out infinite;
    }
    @keyframes buffPulse{
      0%,100%{ transform: scale(1); filter: brightness(1); }
      50%{ transform: scale(1.06); filter: brightness(1.18); }
    }

    .bossFlash{ animation: bossFlash .14s linear; }
    @keyframes bossFlash{
      0%{ filter: brightness(1) contrast(1) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
      50%{ filter: brightness(2.4) contrast(1.2) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
      100%{ filter: brightness(1) contrast(1) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
    }

    .damageFlash{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: rgba(255, 0, 0, .22);
      opacity:0;
      z-index:6;
    }
    .damageFlash.show{ animation: dmgFlash .22s ease-out; }
    @keyframes dmgFlash{
      0%{ opacity:0; }
      25%{ opacity:1; }
      100%{ opacity:0; }
    }

    /* Bottom UI */
    .uiRow{
      display:grid;
      grid-template-columns: 1fr 1.2fr 1.1fr;
      gap:10px;
      padding:10px;
      background: rgba(0,0,0,.22);
    }

    .panel{
      background: linear-gradient(180deg, rgba(26,22,48,.92), rgba(18,16,34,.92));
      border:6px solid var(--gold);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.55);
      padding:10px;
      min-height: 160px;
    }

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      padding-bottom:6px;
      border-bottom:2px solid rgba(255,255,255,.12);
      color: var(--muted);
      font-size:12px;
    }
    .panelHeader b{ color: var(--ink); }

    .menuList{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:6px;
      font-size:16px;
    }
    .menuItem{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 6px;
      border:2px solid transparent;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }
    .menuItem:hover{
      border-color: rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
    }
    .arrow{
      width:18px;
      color: var(--gold);
      font-weight:900;
    }

    .msg{
      font-size:14px;
      line-height:1.55;
      color: var(--ink);
      min-height: 120px;
      padding:6px 6px 10px;
      border:2px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      overflow:auto;
      max-height: 140px;
    }
    .msg .muted{ color: var(--muted); }

    .small{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
    }

    .statusList{ display:grid; gap:10px; font-size:13px; }
    .statRow{
      display:grid;
      grid-template-columns: auto 1fr;
      gap:10px;
      align-items:center;
    }
    .statRow .name{
      width: 90px;
      color: var(--ink);
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .bars{ display:grid; gap:6px; }
    .barLine{
      display:grid;
      grid-template-columns: 28px 1fr auto;
      gap:8px;
      align-items:center;
      color: var(--muted);
      font-size:12px;
    }
    .meter{
      height: 12px;
      border:3px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(255,255,255,.08);
      overflow:hidden;
    }
    .fillHP{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(214,66,66,1), rgba(255,140,140,1));
    }
    .fillBoss{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(255,110,90,1), rgba(255,190,120,1));
    }
    .fillAP{
      height:100%;
      width:40%;
      background: linear-gradient(90deg, rgba(106,70,255,1), rgba(170,140,255,1));
    }

    .hpPips{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
      margin-top:8px;
      padding-top:8px;
      border-top:2px solid rgba(255,255,255,.10);
    }
    .pip{
      width:12px;
      height:12px;
      border:2px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(255,255,255,.08);
    }
    .pip.on{
      background: linear-gradient(90deg, rgba(49,210,124,1), rgba(120,255,190,1));
    }

    .bgmRow{
      margin-top:8px;
      padding-top:8px;
      border-top:2px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size:12px;
    }
    .bgmRow b{ color: var(--ink); }
    .bgmRow input[type="range"]{
      width: 140px;
      accent-color: var(--gold);
    }
    .bgmBtn{
      border:2px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      padding:8px 10px;
      cursor:pointer;
      font-family: inherit;
      font-size:12px;
      font-weight:900;
      min-height: 40px;
      touch-action: manipulation;
    }

    .overlay{
      position:absolute;
      inset:0;
      display:none;
      place-items:center;
      z-index:10;
      background: rgba(0,0,0,.55);
      cursor:pointer;
    }
    .overlay.show{ display:grid; }
    .overlayBox{
      width:min(600px, calc(100% - 30px));
      background: linear-gradient(180deg, rgba(26,22,48,.95), rgba(18,16,34,.95));
      border:6px solid var(--gold);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.55);
      padding:14px;
      text-align:left;
      overflow:hidden;
    }
    .overlayBox h2{ margin:0 0 8px; font-size:18px; }
    .overlayBox p{ margin:0; color: var(--ink); font-size:14px; line-height:1.7; }
    .overlayHint{ margin-top:10px; color: var(--muted); font-size:12px; }
    .countdown{ margin-top:10px; font-size:42px; font-weight:900; color: var(--gold); text-align:center; }

    .overlayChoices{
      display:none;
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .overlayChoices.show{ display:grid; }

    .choiceBtn{
      cursor:pointer;
      user-select:none;
      background: rgba(0,0,0,.22);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      padding:12px;
      touch-action: manipulation;
    }
    .choiceBtn:hover{
      outline:2px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.04);
    }
    .choiceBtn .title{
      font-weight:900;
      color: var(--gold);
      margin-bottom:4px;
    }
    .choiceBtn .desc{
      font-size:13px;
      color: var(--ink);
      line-height:1.55;
    }
    .choiceBtn .note{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
    }

    .stageClearSlide{
      display:inline-block;
      font-size:26px;
      letter-spacing:.5px;
      animation: stageClearSlide .55s cubic-bezier(.18,.9,.22,1) both;
    }
    @keyframes stageClearSlide{
      0%   { transform: translateX(-56px); opacity: 0; }
      65%  { transform: translateX(8px); opacity: 1; }
      100% { transform: translateX(0); opacity: 1; }
    }

    @media (max-width: 980px){
      .uiRow{ grid-template-columns: 1fr; }
      .panel{ min-height: unset; }
      .bossWrap{ right: 18px; top: 34px; bottom: 34px; width: 46%; }
      .wordLane{ width: 52%; }
      .inputBar{ width: 52%; }
      .stage5Timer{ top: 52px; }
      .stage5InvSign{ top: 102px; }
    }
  </style>
</head>
<body>
  <div class="frame pixel">
    <div class="battlefield" id="battlefield">
      <div class="bgFallback" id="bgFallback"></div>
      <img class="bgImg pixel" id="bgImg" alt="Stage background" />

      <div class="damageFlash" id="damageFlash"></div>

      <div class="laneLabel">Words</div>
      <div class="wordLane" id="wordLane"></div>

      <!-- Input is directly under the falling words -->
      <div class="inputBar" id="inputBar">
        <form id="answerForm" autocomplete="off">
          <div class="promptChar">&gt;</div>
          <input
            id="answerInput"
            type="text"
            placeholder="英語を入力… 例: taller / the tallest"
            autocomplete="off"
            autocapitalize="none"
            autocorrect="off"
            spellcheck="false"
            inputmode="text"
            enterkeyhint="done"
            disabled
          />
          <button type="submit" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;">OK</button>
        </form>
      </div>

      <div class="bossWrap">
        <div class="bossInner">
          <div class="bossBubble" id="bossBubble"></div>

          <div class="stage5Timer" id="stage5Timer">残り --:--</div>
          <!-- NEW: flashing sign under the timer -->
          <div class="stage5InvSign" id="stage5InvSign">一時的無敵</div>

          <div class="bossBuffBanner" id="stage5InvBanner">一時的無敵</div>

          <img class="bossImg pixel" id="bossImg" alt="Boss sprite" />
          <div class="bossFallback" id="bossFallback">
            Stage Boss<br>
            <span style="color:var(--muted); font-weight:700; font-size:12px;">(stage?_boss.png を置く)</span>
          </div>
        </div>
      </div>

      <div class="overflowBadge" id="overflowBadge">OVERFLOW! 1 dmg/sec</div>

      <div class="overlay" id="overlay">
        <div class="overlayBox" role="dialog" aria-modal="true">
          <h2 id="overlayTitle">READY</h2>
          <p id="overlayDesc">Fight (Start) を選んで開始</p>

          <div class="overlayChoices" id="overlayChoices"></div>

          <div class="overlayHint" id="overlayHint">▶ Enter または クリックで進む</div>
          <div class="countdown" id="countdownText"></div>
        </div>
      </div>
    </div>

    <div class="uiRow">
      <div class="panel">
        <div class="panelHeader">
          <span><b id="playerLabel">Player</b></span>
          <span class="muted">Commands</span>
        </div>
        <ul class="menuList">
          <li class="menuItem" id="startCmd"><span class="arrow">▶</span><span>Fight (Start)</span></li>
          <li class="menuItem" id="resetCmd"><span class="arrow">▶</span><span>Reset</span></li>
          <li class="menuItem" id="runCmd"><span class="arrow">▶</span><span>Run (Reset)</span></li>
        </ul>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <span>Stage: <b id="stageName">-</b></span>
          <span>Boss: <b id="bossName">-</b></span>
        </div>

        <div class="msg" id="msgBox">
          <div>ルール：<span class="muted">日本語が落ちる → 英語をタイプして攻撃</span></div>
          <div class="muted">（オーバーフロー中は毎秒ダメージ）</div>
        </div>

        <div class="small">※ 大文字小文字は無視（the tallest / The Tallest OK）</div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <span>Status</span>
          <span>Miss: <b id="mistakesText">0</b></span>
        </div>

        <div class="statusList">
          <div class="statRow">
            <div class="name">Boss</div>
            <div class="bars">
              <div class="barLine">
                <span>HP</span>
                <div class="meter"><div class="fillBoss" id="bossFill"></div></div>
                <span><b id="bossHpText">-</b></span>
              </div>
              <div class="barLine">
                <span>DMG</span>
                <div class="meter"><div class="fillAP" id="dmgFill"></div></div>
                <span><b id="hitDamageText">-</b></span>
              </div>
            </div>
          </div>

          <div class="statRow">
            <div class="name">Player</div>
            <div class="bars">
              <div class="barLine">
                <span>HP</span>
                <div class="meter"><div class="fillHP" id="playerFill"></div></div>
                <span><b id="playerHpText">-</b></span>
              </div>
            </div>
          </div>

          <div class="hpPips" id="hpPips" aria-label="HP pips"></div>

          <div class="small">
            Buff: <b id="buffText">None</b> /
            Invuln: <b id="invulnText">OFF</b> /
            Continues: <b id="continuesText">3</b>
          </div>

          <div class="bgmRow">
            <span>BGM:</span>
            <input id="bgmVol" type="range" min="0" max="100" value="35" />
            <span><b id="bgmVolText">35%</b></span>
            <button class="bgmBtn" id="bgmMuteBtn">MUTE</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  async function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // ✅ VOCAB LIST
  const WORDS = [
    { prompt:"背が高い", answer:"tall" },
    { prompt:"より背が高い", answer:"taller" },
    { prompt:"一番背が高い", answer:"the tallest" },

    { prompt:"長い", answer:"long" },
    { prompt:"より長い", answer:"longer" },
    { prompt:"一番長い", answer:"the longest" },

    { prompt:"古い(年上の)", answer:"old" },
    { prompt:"より古い(年上の)", answer:"older" },
    { prompt:"一番古い(年上の)", answer:"the oldest" },

    { prompt:"若い(年下の)", answer:"young" },
    { prompt:"より若い(年下の)", answer:"younger" },
    { prompt:"一番若い(年下の)", answer:"the youngest" },

    { prompt:"小さい", answer:"small" },
    { prompt:"より小さい", answer:"smaller" },
    { prompt:"一番小さい", answer:"the smallest" },

    { prompt:"大きい（広い）", answer:"large" },
    { prompt:"より大きい（広い）", answer:"larger" },
    { prompt:"一番大きい（広い）", answer:"the largest" },

    { prompt:"大きい", answer:"big" },
    { prompt:"より大きい", answer:"bigger" },
    { prompt:"一番大きい", answer:"the biggest" },

    { prompt:"暑い", answer:"hot" },
    { prompt:"より暑い", answer:"hotter" },
    { prompt:"一番暑い", answer:"the hottest" },

    { prompt:"簡単な", answer:"easy" },
    { prompt:"より簡単な", answer:"easier" },
    { prompt:"一番簡単な", answer:"the easiest" },

    { prompt:"重い", answer:"heavy" },
    { prompt:"より重い", answer:"heavier" },
    { prompt:"一番重い", answer:"the heaviest" },

    { prompt:"新しい", answer:"new" },
    { prompt:"より新しい", answer:"newer" },
    { prompt:"一番新しい", answer:"the newest" },

    { prompt:"かっこいい", answer:"cool" },
    { prompt:"よりかっこいい", answer:"cooler" },
    { prompt:"一番かっこいい", answer:"the coolest" },

    { prompt:"寒い", answer:"cold" },
    { prompt:"より寒い", answer:"colder" },
    { prompt:"一番寒い", answer:"the coldest" },

    { prompt:"強い", answer:"strong" },
    { prompt:"より強い", answer:"stronger" },
    { prompt:"一番強い", answer:"the strongest" },

    { prompt:"あたたかい", answer:"warm" },
    { prompt:"よりあたたかい", answer:"warmer" },
    { prompt:"一番あたたかい", answer:"the warmest" },

    { prompt:"短い", answer:"short" },
    { prompt:"より短い", answer:"shorter" },
    { prompt:"一番短い", answer:"the shortest" },

    { prompt:"速い", answer:"fast" },
    { prompt:"より速い", answer:"faster" },
    { prompt:"一番速い", answer:"the fastest" },

    { prompt:"すばらしい", answer:"great" },
    { prompt:"よりすばらしい", answer:"greater" },
    { prompt:"一番すばらしい", answer:"the greatest" },
  ];

  const AUDIO = {
    victoryBgm: "victory_bgm.mp3",
    deathBgm: "death_bgm.mp3",
    bossHitSfx: "boss_hit.mp3",
    dialogueBgm: "dialogue_bgm.mp3",
  };

  const STAGES = [
    {
      stageName: "Stage 1",
      bossName: "能海先生",
      bossDialogue: "English RPGへようこそ！いっしょに楽しもう！",
      midFightDialogue: "痛っ！",
      bossMaxHp: 18,
      hitDamage: 1,
      spawnEveryMs: 3297,
      fallSpeedPxPerSec: 38,
      bgFile: "stage1_bg.png",
      bossFile: "stage1_boss.png",
      bossDamagedFile: "stage1_boss_dmg.png",
      dialogueBgmFile: "dialogue_bgm.mp3",
      playBgmFile: "stage1_bgm.mp3",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 2",
      bossName: "アル",
      bossDialogue: "能海先生がステージ1のボスだって？ ハハハハハ！ そんな簡単には負けないぞ。",
      midFightDialogue: "私を叩くな！能海先生を叩け！",
      bossMaxHp: 22,
      hitDamage: 1,
      spawnEveryMs: 2500,
      fallSpeedPxPerSec: 32,
      bgFile: "stage2_bg.png",
      bossFile: "stage2_boss.png",
      bossDamagedFile: "stage2_boss_dmg.png",
      dialogueBgmFile: "dialogue_bgm.mp3",
      playBgmFile: "stage2_bgm.mp3",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 3",
      bossName: "アカリ",
      bossDialogue: "アルを殺したかった!!!! 次はお前だ！",
      midFightDialogue: "お前なんか大嫌い！",
      bossMaxHp: 26,
      hitDamage: 1,
      spawnEveryMs: 1696,
      fallSpeedPxPerSec: 45,
      bgFile: "stage3_bg.png",
      bossFile: "stage3_boss.png",
      bossDamagedFile: "stage3_boss_dmg.png",
      dialogueBgmFile: "dialogue_bgm.mp3",
      playBgmFile: "stage3_bgm.mp3",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 4",
      bossName: "Dragon",
      bossDialogue: "グオオオオオオオオォォォ！！",
      midFightDialogue: "ギャアアアアアッ！！",
      bossMaxHp: 30,
      hitDamage: 1,
      spawnEveryMs: 1316,
      fallSpeedPxPerSec: 55,
      bgFile: "stage4_bg.png",
      bossFile: "stage4_boss.png",
      bossDamagedFile: "stage4_boss_dmg.png",
      dialogueBgmFile: "dialogue_bgm.mp3",
      playBgmFile: "stage4_bgm.mp3",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 5",
      bossName: "能海様",
      bossDialogue: "しゃて。。。。",
      bossMaxHp: 10,
      hitDamage: 1,
      spawnEveryMs: 1150,
      fallSpeedPxPerSec: 65,
      bgFile: "stage5_bg.png",
      bossFile: "stage5_boss.png",
      bossDamagedFile: "stage5_boss_dmg.png",
      bossFile2: "stage5_boss2.png",
      bossDamagedFile2: "stage5_boss2_dmg.png",
      bossFile3: "stage5_boss3.png",
      bossDamagedFile3: "stage5_boss3_dmg.png",
      dialogueBgmFile: "dialogue_bgm.mp3",
      playBgmFile: "stage5_bgm.mp3",
      playBgmLoop: false,
      words: WORDS
    }
  ];

  const BASE_PLAYER_MAX_HP = 10;
  const CHEAT_SKIP_STAGE5 = "657810";

  const MAX_CONTINUES = 3;
  const CONTINUE_HP = 3;
  const CONTINUE_DECISION_SEC = 10;

  const wordLane = document.getElementById("wordLane");
  const overflowBadge = document.getElementById("overflowBadge");

  const bgImg = document.getElementById("bgImg");
  const bgFallback = document.getElementById("bgFallback");

  const bossImg = document.getElementById("bossImg");
  const bossFallback = document.getElementById("bossFallback");
  const bossBubble = document.getElementById("bossBubble");
  const stage5InvBanner = document.getElementById("stage5InvBanner");
  const stage5Timer = document.getElementById("stage5Timer");
  const stage5InvSign = document.getElementById("stage5InvSign"); // NEW

  const damageFlash = document.getElementById("damageFlash");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayDesc = document.getElementById("overlayDesc");
  const overlayChoices = document.getElementById("overlayChoices");
  const overlayHint = document.getElementById("overlayHint");
  const countdownText = document.getElementById("countdownText");

  const stageNameEl = document.getElementById("stageName");
  const bossNameEl = document.getElementById("bossName");

  const bossFill = document.getElementById("bossFill");
  const bossHpText = document.getElementById("bossHpText");
  const hitDamageText = document.getElementById("hitDamageText");
  const dmgFill = document.getElementById("dmgFill");

  const playerFill = document.getElementById("playerFill");
  const playerHpText = document.getElementById("playerHpText");
  const mistakesText = document.getElementById("mistakesText");

  const buffText = document.getElementById("buffText");
  const invulnText = document.getElementById("invulnText");
  const continuesText = document.getElementById("continuesText");

  const msgBox = document.getElementById("msgBox");
  const answerForm = document.getElementById("answerForm");
  const answerInput = document.getElementById("answerInput");

  const hpPipsEl = document.getElementById("hpPips");

  const startCmd = document.getElementById("startCmd");
  const resetCmd = document.getElementById("resetCmd");
  const runCmd = document.getElementById("runCmd");

  const bgmVol = document.getElementById("bgmVol");
  const bgmVolText = document.getElementById("bgmVolText");
  const bgmMuteBtn = document.getElementById("bgmMuteBtn");

  function showOverlay(show){ overlay.classList.toggle("show", show); }
  function setOverlayText(title, desc, hint){
    overlayTitle.textContent = title;
    overlayDesc.textContent = desc;
    overlayHint.textContent = hint;
    countdownText.textContent = "";
    overlayChoices.classList.remove("show");
    overlayChoices.innerHTML = "";
    overlay.style.cursor = "pointer";
  }
  function setOverlayTitleStageClear(stageName){
    overlayTitle.innerHTML = `<span class="stageClearSlide">${escapeHtml(stageName)} Clear</span>`;
  }

  function pushMsg(text, muted=false){
    const div = document.createElement("div");
    div.textContent = text;
    if(muted) div.className = "muted";
    msgBox.appendChild(div);
    while(msgBox.children.length > 8) msgBox.removeChild(msgBox.firstChild);
    msgBox.scrollTop = msgBox.scrollHeight;
  }

  function showStage5Timer(show){
    stage5Timer.classList.toggle("show", !!show);
    // NEW: show flashing sign whenever timer is shown
    stage5InvSign.classList.toggle("show", !!show);
  }

  function formatTime(sec){
    const s = Math.max(0, Math.ceil(sec));
    const m = Math.floor(s / 60);
    const ss = String(s % 60).padStart(2, "0");
    return `${m}:${ss}`;
  }
  function updateStage5Timer(){
    if(!(gameState === "playing" && stageIndex === 4 && stage5Phase >= 2)){
      showStage5Timer(false);
      return;
    }
    showStage5Timer(true);

    const dur = (Number.isFinite(bgm.duration) && bgm.duration > 0) ? bgm.duration : null;
    if(dur == null){
      stage5Timer.textContent = "残り --:--";
      return;
    }
    const rem = Math.max(0, dur - bgm.currentTime);
    stage5Timer.textContent = `残り ${formatTime(rem)}`;
  }

  let bossBubbleTimer = null;
  function showBossBubble(text, ms=4000){
    if(bossBubbleTimer){ clearTimeout(bossBubbleTimer); bossBubbleTimer = null; }
    bossBubble.textContent = text;
    bossBubble.classList.add("show");
    bossBubbleTimer = setTimeout(() => {
      bossBubble.classList.remove("show");
      bossBubble.textContent = "";
      bossBubbleTimer = null;
    }, ms);
  }
  function hideBossBubble(){
    if(bossBubbleTimer){ clearTimeout(bossBubbleTimer); bossBubbleTimer = null; }
    bossBubble.classList.remove("show");
    bossBubble.textContent = "";
  }

  function setStage5InvBanner(show){
    stage5InvBanner.classList.toggle("show", !!show);
  }

  const bgm = new Audio();
  bgm.preload = "auto";
  bgm.loop = true;

  let currentBgm = "";
  let isMuted = false;
  let lastVol = 0.35;
  let audioUnlocked = false;

  let savedBgmState = null;
  function saveBgmState(){
    savedBgmState = {
      src: currentBgm || (bgm.currentSrc || ""),
      time: Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0,
      loop: !!bgm.loop
    };
  }
  function restoreBgmState(){
    if(!savedBgmState || !savedBgmState.src) return;
    const {src, time, loop} = savedBgmState;
    setBgm(src, loop);
    try{ bgm.currentTime = Math.max(0, time || 0); }catch(_){}
    savedBgmState = null;
  }

  function pushAudioHintOnce(){
    pushMsg("⚠️ Safari/iOS：最初に画面をタップしてから開始すると音が出やすいです", true);
  }

  function setBgmVolume(v01){
    const v = Math.max(0, Math.min(1, v01));
    lastVol = v;
    if(!isMuted) bgm.volume = v;
    bgmVol.value = String(Math.round(v * 100));
    bgmVolText.textContent = `${Math.round(v * 100)}%`;
  }
  function toggleMute(){
    isMuted = !isMuted;
    if(isMuted){
      bgm.volume = 0;
      bgmMuteBtn.textContent = "UNMUTE";
    }else{
      bgm.volume = lastVol;
      bgmMuteBtn.textContent = "MUTE";
    }
  }
  async function tryPlayBgm(){
    try{ await bgm.play(); }
    catch(_){ pushAudioHintOnce(); }
  }
  function setBgm(src, loop=true){
    bgm.loop = !!loop;
    if(!src){ stopBgm(); return; }
    if(currentBgm !== src){
      currentBgm = src;
      bgm.src = src;
      bgm.currentTime = 0;
    }
    tryPlayBgm();
  }
  function stopBgm(){
    currentBgm = "";
    bgm.pause();
    bgm.removeAttribute("src");
    bgm.load();
  }

  const sfxPool = { bossHit: [], idx: 0 };
  function initSfxPool(){
    const n = 4;
    sfxPool.bossHit = Array.from({length:n}, () => {
      const a = new Audio(AUDIO.bossHitSfx);
      a.preload = "auto";
      a.volume = 0.55;
      return a;
    });
  }
  function playBossHitSfx(){
    const arr = sfxPool.bossHit;
    if(!arr || arr.length === 0) return;
    const a = arr[sfxPool.idx % arr.length];
    sfxPool.idx++;
    try{ a.currentTime = 0; a.play().catch(()=>{}); }catch(_){}
  }

  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked = true;

    bgm.volume = isMuted ? 0 : lastVol;
    bgm.play().then(()=>bgm.pause()).catch(()=>{});

    const a = sfxPool.bossHit?.[0];
    if(a) a.play().then(()=>a.pause()).catch(()=>{});
  }
  window.addEventListener("pointerdown", unlockAudioOnce, { once:true });
  window.addEventListener("keydown", unlockAudioOnce, { once:true });

  // ---- Buffs ----
  let selectedBuff = null;
  let bossDamageMult = 1;
  let playerDamageMult = 1;

  let invulnActive = false;
  let invulnUsed = false;
  let invulnUntil = 0;

  function resetBuffState(){
    selectedBuff = null;
    bossDamageMult = 1;
    playerDamageMult = 1;
    invulnActive = false;
    invulnUsed = false;
    invulnUntil = 0;
  }

  function buffLabel(){
    if(selectedBuff === "buff1") return "1) Double DMG / Double DMG taken";
    if(selectedBuff === "buff2") return "2) Hint words (every 3rd spawn)";
    if(selectedBuff === "buff3") return "3) 1-time 5s Invuln at 0 HP";
    return "None";
  }

  function applyBuffSelection(buffId){
    selectedBuff = buffId;

    bossDamageMult = 1;
    playerDamageMult = 1;

    invulnActive = false;
    invulnUsed = false;
    invulnUntil = 0;

    if(buffId === "buff1"){
      bossDamageMult = 2;
      playerDamageMult = 2;
    }
  }

  function showBuffSelect(){
    return new Promise((resolve) => {
      gameState = "buffselect";
      setInputsEnabled(false);

      setBgm(AUDIO.dialogueBgm, true);

      showOverlay(true);
      overlayTitle.textContent = "Choose a Buff";
      overlayDesc.textContent = "ステージ1の前に、1つだけバフを選んでください（この1回のプレイだけ有効）";
      overlayHint.textContent = "▶ クリックで選択";
      countdownText.textContent = "";
      overlay.style.cursor = "pointer";

      overlayChoices.classList.add("show");
      overlayChoices.innerHTML = `
        <div class="choiceBtn" data-buff="buff1">
          <div class="title">Buff 1</div>
          <div class="desc">与えるダメージ2倍 / 受けるダメージ2倍</div>
          <div class="note">（強いけどリスク大）</div>
        </div>
        <div class="choiceBtn" data-buff="buff2">
          <div class="title">Buff 2</div>
          <div class="desc">落下/積み上がった単語に英語ヒントが付くことがある</div>
          <div class="note">（3つ落ちるごとに1つ、英語が表示）</div>
        </div>
        <div class="choiceBtn" data-buff="buff3">
          <div class="title">Buff 3</div>
          <div class="desc">HPが0になる直前：1回だけHP1で耐えて、5秒無敵</div>
          <div class="note">（発動は1回だけ）</div>
        </div>
      `;

      const onClick = (e) => {
        const btn = e.target.closest(".choiceBtn");
        if(!btn) return;
        const id = btn.getAttribute("data-buff");
        applyBuffSelection(id);
        cleanup();
        showOverlay(false);
        resolve();
      };

      const cleanup = () => {
        overlayChoices.innerHTML = "";
        overlayChoices.classList.remove("show");
        overlay.removeEventListener("click", onClick);
      };

      overlay.addEventListener("click", onClick);
    });
  }

  // ---- Game state ----
  let gameState = "idle";
  let stageIndex = 0;

  let bossHp = 0;
  let bossMaxHp = 0;
  let baseHitDamage = 1;

  let playerMaxHp = BASE_PLAYER_MAX_HP;
  let playerHp = BASE_PLAYER_MAX_HP;
  let mistakes = 0;

  let continuesLeft = MAX_CONTINUES;
  let continuePromptUntilMs = 0;
  let continueListeners = null;

  let wordsOnField = [];
  let nextWordId = 1;

  let lastTs = 0;
  let overflow = false;
  let overflowAcc = 0;

  let stagePlayStartMs = 0;
  let stagePausedTotalMs = 0;
  let stagePauseStartMs = null;

  let spawnAccMs = 0;

  let spawnCountThisStage = 0;
  let midFightBubbleShown = false;

  let stage5Phase = 1;
  let stage5EndedHandled = false;
  let stage5InvShown = false;
  let stage5Phase2At = null;
  let stage5Phase3At = null;

  let bossNormalSrc = "";
  let bossDamagedSrc = "";
  let bossDamageTimeout = null;
  let bossDamagedAvailable = false;

  function setInputsEnabled(enabled){
    answerInput.disabled = !enabled;
    if(enabled){
      answerInput.focus();
    }else{
      answerInput.blur();
      answerInput.value = "";
    }
  }

  function renderHpPips(){
    hpPipsEl.innerHTML = "";
    for(let i=0;i<playerMaxHp;i++){
      const pip = document.createElement("div");
      pip.className = "pip" + (i < playerHp ? " on" : "");
      hpPipsEl.appendChild(pip);
    }
  }

  function updateUI(){
    const stage = STAGES[stageIndex] || null;
    stageNameEl.textContent = stage ? stage.stageName : "-";
    bossNameEl.textContent = stage ? stage.bossName : "-";

    bossHpText.textContent = `${bossHp}/${bossMaxHp}`;
    const effectiveHit = baseHitDamage * bossDamageMult;
    hitDamageText.textContent = String(effectiveHit);
    bossFill.style.width = `${(bossMaxHp ? clamp(bossHp/bossMaxHp,0,1) : 0) * 100}%`;

    playerHpText.textContent = `${playerHp}/${playerMaxHp}`;
    playerFill.style.width = `${clamp(playerHp/playerMaxHp,0,1) * 100}%`;

    mistakesText.textContent = String(mistakes);
    continuesText.textContent = String(continuesLeft);

    overflowBadge.classList.toggle("show", overflow);
    dmgFill.style.width = `${clamp(effectiveHit/5,0,1) * 100}%`;

    buffText.textContent = buffLabel();
    invulnText.textContent = invulnActive ? "ON" : (selectedBuff === "buff3" && invulnUsed ? "USED" : "OFF");

    renderHpPips();
  }

  function flashPlayerDamage(){
    damageFlash.classList.remove("show");
    void damageFlash.offsetWidth;
    damageFlash.classList.add("show");
  }

  function resetField(){
    for(const w of wordsOnField) w.el.remove();
    wordsOnField = [];
    overflow = false;
    overflowAcc = 0;
  }
  function laneHeight(){ return wordLane.clientHeight; }
  function laneCapacity(){ return Math.floor(laneHeight() / 30); }
  function landedWords(){ return wordsOnField.filter(w => w.state === "landed"); }

  function restackLanded(){
    const h = laneHeight();
    const landed = landedWords().sort((a,b)=> b.y - a.y);
    for(let i=0;i<landed.length;i++){
      const y = h - 30 * (i+1);
      landed[i].y = y;
      landed[i].el.style.top = `${y}px`;
    }
    overflow = landed.length >= laneCapacity();
    updateUI();
  }

  function pickStageWord(){
    const stage = STAGES[stageIndex];
    const w = stage.words[Math.floor(Math.random() * stage.words.length)];
    return { prompt: w.prompt, answer: w.answer };
  }

  function spawnWord(){
    if(gameState !== "playing") return;

    const {prompt, answer} = pickStageWord();

    spawnCountThisStage++;
    const showHintNow = (selectedBuff === "buff2" && (spawnCountThisStage % 3 === 0));

    const el = document.createElement("div");
    el.className = "word" + (showHintNow ? " hint" : "");
    el.innerHTML = `<div class="prompt">${escapeHtml(prompt)}</div><div class="tag">${showHintNow ? escapeHtml(answer) : "type"}</div>`;
    wordLane.appendChild(el);

    const obj = {
      id: nextWordId++,
      prompt,
      answer,
      y: -30,
      state: "falling",
      el,
      showHint: showHintNow
    };
    el.style.top = `${obj.y}px`;
    wordsOnField.push(obj);
  }

  function normalizeAnswer(s){
    return String(s).trim().toLowerCase().replace(/\s+/g, " ");
  }

  function removeWord(id){
    const idx = wordsOnField.findIndex(w => w.id === id);
    if(idx === -1) return;
    wordsOnField[idx].el.remove();
    wordsOnField.splice(idx,1);
    restackLanded();
  }

  function preloadImage(src){
    return new Promise((resolve) => {
      if(!src){ resolve(false); return; }
      const im = new Image();
      im.onload = () => resolve(true);
      im.onerror = () => resolve(false);
      im.src = src;
    });
  }

  async function setBossVariant(stage, phase){
    let normal = stage.bossFile || "";
    let damaged = stage.bossDamagedFile || "";

    if(phase === 2){
      normal = stage.bossFile2 || stage.bossFile || "";
      damaged = stage.bossDamagedFile2 || stage.bossDamagedFile || "";
    }else if(phase === 3){
      normal = stage.bossFile3 || stage.bossFile2 || stage.bossFile || "";
      damaged = stage.bossDamagedFile3 || stage.bossDamagedFile2 || stage.bossDamagedFile || "";
    }

    bossNormalSrc = normal;
    bossDamagedSrc = damaged;

    bossDamagedAvailable = await preloadImage(bossDamagedSrc);

    bossImg.style.display = "none";
    bossFallback.style.display = "grid";
    bossFallback.innerHTML =
      `${escapeHtml(stage.bossName)}<br><span style="color:var(--muted); font-weight:700; font-size:12px;">(${escapeHtml(normal || "stage?_boss.png")} を置く)</span>`;

    if(bossDamageTimeout){ clearTimeout(bossDamageTimeout); bossDamageTimeout = null; }

    bossImg.onload = () => { bossImg.style.display = "block"; bossFallback.style.display = "none"; };
    bossImg.onerror = () => { bossImg.style.display = "none"; bossFallback.style.display = "grid"; };

    bossImg.src = bossNormalSrc || "";
  }

  function showBossDamagedBriefly(){
    if(bossImg.style.display !== "block") return;

    if(bossDamagedAvailable && bossDamagedSrc){
      bossImg.src = bossDamagedSrc;
      if(bossDamageTimeout) clearTimeout(bossDamageTimeout);
      bossDamageTimeout = setTimeout(() => { bossImg.src = bossNormalSrc; }, 140);
    }else{
      bossImg.classList.remove("bossFlash");
      void bossImg.offsetWidth;
      bossImg.classList.add("bossFlash");
    }
  }

  async function setStageArt(stage){
    bgImg.style.display = "none";
    bgFallback.style.display = "block";
    bgImg.onload = () => { bgImg.style.display = "block"; bgFallback.style.display = "none"; };
    bgImg.onerror = () => { bgImg.style.display = "none"; bgFallback.style.display = "block"; };
    bgImg.src = stage.bgFile || "";

    await setBossVariant(stage, 1);
  }

  function nowMs(){ return performance.now(); }

  function stageElapsedSec(){
    if(!stagePlayStartMs) return 0;
    const base = nowMs() - stagePlayStartMs;
    const pausedSoFar = stagePausedTotalMs + (stagePauseStartMs ? (nowMs() - stagePauseStartMs) : 0);
    return Math.max(0, (base - pausedSoFar) / 1000);
  }

  function stage5DurationSec(){
    return (Number.isFinite(bgm.duration) && bgm.duration > 0) ? bgm.duration : null;
  }

  function stage5CurrentFallSpeed(elapsed){
    const s1 = STAGES[0].fallSpeedPxPerSec;
    const s2 = STAGES[1].fallSpeedPxPerSec;
    const s3 = STAGES[2].fallSpeedPxPerSec;
    const s5 = STAGES[4].fallSpeedPxPerSec;

    const t2 = stage5Phase2At ?? Infinity;
    const t3 = stage5Phase3At ?? Infinity;

    if(elapsed < t2) return s1;
    if(elapsed < t3) return s2;

    const dur = stage5DurationSec();
    if(dur != null){
      const last5 = Math.max(t3, dur - 5);
      if(elapsed >= dur - 5){
        return s5 * 20;
      }
      const denom = Math.max(0.001, last5 - t3);
      const p = clamp((elapsed - t3) / denom, 0, 1);
      return s3 + (s5 - s3) * p;
    }

    const p = clamp((elapsed - t3) / 20, 0, 1);
    return s3 + (s5 - s3) * p;
  }

  function stage5CurrentSpawnMs(elapsed){
    const a1 = STAGES[0].spawnEveryMs;
    const a2 = STAGES[1].spawnEveryMs;
    const a3 = STAGES[2].spawnEveryMs;
    const a5 = STAGES[4].spawnEveryMs;

    const t2 = stage5Phase2At ?? Infinity;
    const t3 = stage5Phase3At ?? Infinity;

    if(elapsed < t2) return a1;
    if(elapsed < t3) return a2;

    const dur = stage5DurationSec();
    if(dur != null){
      const last5 = Math.max(t3, dur - 5);
      const denom = Math.max(0.001, last5 - t3);
      const p = clamp((elapsed - t3) / denom, 0, 1);
      return Math.round(a3 + (a5 - a3) * p);
    }

    const p = clamp((elapsed - t3) / 20, 0, 1);
    return Math.round(a3 + (a5 - a3) * p);
  }

  async function stage5SetPhase(targetPhase){
    const stage = STAGES[4];
    if(stageIndex !== 4) return;
    if(targetPhase <= stage5Phase) return;

    for(let p = stage5Phase + 1; p <= targetPhase; p++){
      stage5Phase = p;

      const e = stageElapsedSec();
      if(p === 2 && stage5Phase2At == null) stage5Phase2At = e;
      if(p === 3 && stage5Phase3At == null) stage5Phase3At = e;

      if(stage5Phase >= 2){
        showStage5Timer(true);
        updateStage5Timer();
      }

      await setBossVariant(stage, p);

      if(p === 2) showBossBubble("私に勝てると思っているのか？", 5000);
      if(p === 3) showBossBubble("我を恐れよ！", 5000);
    }
    updateUI();
  }

  function handleStage5PhaseTriggers(){
    if(stageIndex !== 4 || gameState !== "playing") return;

    const elapsed = stageElapsedSec();

    if(stage5Phase < 2 && (bossHp <= 0 || elapsed >= 16)){
      stage5SetPhase(2);
    }

    if(stage5Phase < 3 && Number.isFinite(bgm.duration) && bgm.duration > 0){
      if(bgm.currentTime >= (bgm.duration / 2)){
        stage5SetPhase(3);
      }
    }
  }

  async function stage5WinByBgmEnd(){
    if(stage5EndedHandled) return;
    stage5EndedHandled = true;

    setInputsEnabled(false);
    hideBossBubble();
    showStage5Timer(false);

    const stage = STAGES[stageIndex];
    await showStageClearScreen(stage);
    onVictory();
  }

  bgm.addEventListener("ended", () => {
    if(gameState === "playing" && stageIndex === 4){
      stage5WinByBgmEnd();
    }
  });

  function findMatchAndClear(input){
    const norm = normalizeAnswer(input);
    if(!norm) return false;

    const candidates = wordsOnField
      .filter(w => normalizeAnswer(w.answer) === norm)
      .sort((a,b)=> b.y - a.y);

    if(candidates.length === 0) return false;

    const target = candidates[0];
    removeWord(target.id);

    damageBoss(baseHitDamage * bossDamageMult);
    pushMsg(`HIT! 「${target.prompt}」→ ${target.answer}`);
    return true;
  }

  function damageBoss(amount){
    if(amount <= 0) return;

    showBossDamagedBriefly();
    playBossHitSfx();

    bossHp = Math.max(0, bossHp - amount);

    if(!midFightBubbleShown && stageIndex >= 0 && stageIndex <= 3){
      const stage = STAGES[stageIndex];
      if(stage?.midFightDialogue && bossHp > 0 && bossHp <= (bossMaxHp / 2)){
        midFightBubbleShown = true;
        showBossBubble(stage.midFightDialogue, 5000);
      }
    }

    updateUI();

    if(stageIndex === 4 && bossHp === 0 && !stage5InvShown){
      stage5InvShown = true;
      setStage5InvBanner(true);
      // the timer & inv sign are controlled by phase>=2 (as requested)
    }

    if(bossHp === 0){
      if(stageIndex === 4){
        stage5SetPhase(2);
        return;
      }
      onBossDefeated();
    }
  }

  function startInvuln(){
    invulnActive = true;
    invulnUntil = nowMs() + 5000;
    pushMsg("★ GUTS! 5秒 無敵！", true);
    updateUI();
  }

  function pauseStageClock(){
    if(stagePauseStartMs == null) stagePauseStartMs = nowMs();
  }
  function resumeStageClock(){
    if(stagePauseStartMs != null){
      stagePausedTotalMs += (nowMs() - stagePauseStartMs);
      stagePauseStartMs = null;
    }
  }

  function damagePlayer(amount, reason){
    if(amount <= 0) return;

    if(invulnActive){
      pushMsg(`NO DMG (invuln): ${reason}`, true);
      return;
    }

    const scaled = Math.max(1, Math.round(amount * playerDamageMult));
    const nextNotice = playerHp - scaled;

    if(selectedBuff === "buff3" && !invulnUsed && nextNotice <= 0){
      invulnUsed = true;
      playerHp = 1;
      flashPlayerDamage();
      startInvuln();
      return;
    }

    playerHp = Math.max(0, playerHp - scaled);
    flashPlayerDamage();
    pushMsg(`Player takes ${scaled} dmg (${reason})`, true);
    updateUI();

    if(playerHp === 0) onPlayerDeath();
  }

  function cleanupContinueListeners(){
    if(!continueListeners) return;
    window.removeEventListener("keydown", continueListeners.onKey);
    overlayChoices.removeEventListener("click", continueListeners.onChoiceClick);
    continueListeners = null;
  }

  function showContinuePrompt(){
    gameState = "continuePrompt";
    setInputsEnabled(false);
    showStage5Timer(false);
    pauseStageClock();

    saveBgmState();
    setBgm(AUDIO.deathBgm, true);

    continuePromptUntilMs = nowMs() + (CONTINUE_DECISION_SEC * 1000);

    showOverlay(true);
    overlay.style.cursor = "default";
    overlayTitle.textContent = "CONTINUE?";
    overlayDesc.textContent = `残りコンティニュー：${continuesLeft}（HP +3）`;
    overlayHint.textContent = "10秒以内に選択";
    overlayChoices.classList.add("show");
    overlayChoices.innerHTML = `
      <div class="choiceBtn" data-act="continue">
        <div class="title">Continue</div>
        <div class="desc">HPを3にして再開（積み上がった単語を全消去）</div>
        <div class="note">残り：${continuesLeft}</div>
      </div>
      <div class="choiceBtn" data-act="reset">
        <div class="title">Reset</div>
        <div class="desc">最初からやり直し（バフ選択から）</div>
      </div>
    `;

    const onChoiceClick = (e) => {
      const btn = e.target.closest(".choiceBtn");
      if(!btn) return;
      const act = btn.getAttribute("data-act");
      if(act === "continue") useContinue();
      if(act === "reset") hardLoseToReset();
    };

    const onKey = (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        useContinue();
      } else if(e.key === "Escape"){
        e.preventDefault();
        hardLoseToReset();
      }
    };

    continueListeners = { onChoiceClick, onKey };
    overlayChoices.addEventListener("click", onChoiceClick);
    window.addEventListener("keydown", onKey);

    updateContinueCountdownText();
  }

  function updateContinueCountdownText(){
    if(gameState !== "continuePrompt") return;
    const remMs = continuePromptUntilMs - nowMs();
    const rem = Math.max(0, Math.ceil(remMs / 1000));
    countdownText.textContent = String(rem);
    if(rem <= 0){
      hardLoseToReset();
    }
  }

  function useContinue(){
    if(gameState !== "continuePrompt") return;
    if(continuesLeft <= 0){
      hardLoseNoContinues();
      return;
    }

    continuesLeft -= 1;

    cleanupContinueListeners();
    showOverlay(false);

    resetField();

    playerHp = Math.min(playerMaxHp, 3);
    overflowAcc = 0;
    overflow = false;

    resumeStageClock();
    restoreBgmState();

    pushMsg(`▶ CONTINUE! HP=${playerHp} / 残り${continuesLeft}`, true);

    gameState = "playing";
    setInputsEnabled(true);
    updateUI();
  }

  function hardLoseNoContinues(){
    cleanupContinueListeners();
    gameState = "gameover";
    setInputsEnabled(false);
    hideBossBubble();
    showStage5Timer(false);
    pauseStageClock();

    setBgm(AUDIO.deathBgm, true);

    showOverlay(true);
    overlay.style.cursor = "pointer";
    setOverlayText("GAME OVER", "コンティニュー切れ。Resetで最初から（バフ選択から）", "（クリックでもOK）");
    pushMsg("💀 GAME OVER（コンティニュー切れ）");
  }

  function hardLoseToReset(){
    cleanupContinueListeners();
    resetGame();
  }

  function onPlayerDeath(){
    if(gameState !== "playing") return;

    if(continuesLeft > 0){
      pushMsg("💀 DOWN... コンティニューしますか？", true);
      showContinuePrompt();
      return;
    }
    hardLoseNoContinues();
  }

  function showBossDialogue(stage){
    return new Promise((resolve) => {
      gameState = "dialogue";
      setInputsEnabled(false);

      setBgm(stage.dialogueBgmFile, true);

      showOverlay(true);
      setOverlayText(stage.bossName, stage.bossDialogue || "……", "▶ Enter または クリックで進む");
      countdownText.textContent = "";

      const proceed = () => { cleanup(); showOverlay(false); resolve(); };
      const onKey = (e) => { if(e.key === "Enter"){ e.preventDefault(); proceed(); } };
      const onClick = () => proceed();

      const cleanup = () => {
        window.removeEventListener("keydown", onKey);
        overlay.removeEventListener("click", onClick);
      };

      window.addEventListener("keydown", onKey);
      overlay.addEventListener("click", onClick);
    });
  }

  async function countdown(seconds){
    gameState = "countdown";
    setInputsEnabled(false);

    showOverlay(true);
    setOverlayText("READY?", "カウントダウン後に開始", "");
    for(let s=seconds; s>=1; s--){
      countdownText.textContent = String(s);
      await sleep(650);
    }
    countdownText.textContent = "GO!";
    await sleep(420);
    showOverlay(false);
  }

  function showStageClearScreen(stage){
    return new Promise((resolve) => {
      gameState = "stageclear";
      setInputsEnabled(false);

      setBgm(AUDIO.victoryBgm, true);

      showOverlay(true);
      setOverlayTitleStageClear(stage.stageName);
      overlayDesc.textContent = `${stage.stageName} クリア！`;
      overlayHint.textContent = "▶ クリック/Enter で次へ（自動でも進みます）";
      countdownText.textContent = "";
      overlayChoices.classList.remove("show");
      overlayChoices.innerHTML = "";

      let allowSkip = false;
      const minShowT = setTimeout(() => { allowSkip = true; }, 450);

      let done = false;
      const finish = () => {
        if(done) return;
        done = true;
        cleanup();
        showOverlay(false);
        resolve();
      };

      const autoT = setTimeout(() => { allowSkip = true; finish(); }, 2200);

      const onKey = (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          if(!allowSkip) return;
          clearTimeout(autoT);
          finish();
        }
      };
      const onClick = () => {
        if(!allowSkip) return;
        clearTimeout(autoT);
        finish();
      };

      const cleanup = () => {
        clearTimeout(minShowT);
        window.removeEventListener("keydown", onKey);
        overlay.removeEventListener("click", onClick);
      };

      window.addEventListener("keydown", onKey);
      overlay.addEventListener("click", onClick);
    });
  }

  async function startStage(idx){
    resetField();
    hideBossBubble();

    spawnAccMs = 0;
    spawnCountThisStage = 0;
    midFightBubbleShown = false;

    showStage5Timer(false);
    setStage5InvBanner(false);
    stage5InvShown = false;

    const stage = STAGES[idx];

    stagePlayStartMs = 0;
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    if(idx === 4){
      stage5Phase = 1;
      stage5EndedHandled = false;
      stage5Phase2At = null;
      stage5Phase3At = null;
      showStage5Timer(false);
    }

    bossMaxHp = stage.bossMaxHp;
    bossHp = stage.bossMaxHp;
    baseHitDamage = stage.hitDamage;

    await setStageArt(stage);
    updateUI();

    msgBox.innerHTML = "";
    pushMsg(`${stage.stageName} 開始！`);
    pushMsg(`Boss: ${stage.bossName}`, true);
    pushMsg(`Buff: ${buffLabel()}`, true);
    pushMsg(`Continues: ${continuesLeft}/${MAX_CONTINUES}`, true);

    await showBossDialogue(stage);
    await countdown(3);

    gameState = "playing";
    setInputsEnabled(true);

    stagePlayStartMs = nowMs();
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    spawnAccMs = 0;

    setBgm(stage.playBgmFile, stage.playBgmLoop !== false);
  }

  async function startGame(){
    cleanupContinueListeners();
    resetField();
    hideBossBubble();
    showStage5Timer(false);
    setStage5InvBanner(false);
    stage5InvShown = false;

    stageIndex = 0;
    mistakes = 0;

    continuesLeft = MAX_CONTINUES;

    if(!selectedBuff){
      await showBuffSelect();
    }

    playerMaxHp = BASE_PLAYER_MAX_HP;
    playerHp = playerMaxHp;

    invulnActive = false;
    invulnUntil = 0;

    showOverlay(false);
    await startStage(0);
  }

  function resetGame(){
    cleanupContinueListeners();

    gameState = "idle";
    resetField();
    hideBossBubble();
    showStage5Timer(false);
    setStage5InvBanner(false);
    stage5InvShown = false;

    spawnAccMs = 0;
    spawnCountThisStage = 0;

    midFightBubbleShown = false;

    resetBuffState();

    playerMaxHp = BASE_PLAYER_MAX_HP;
    playerHp = playerMaxHp;
    mistakes = 0;
    stageIndex = 0;
    bossHp = 0;
    bossMaxHp = 0;

    continuesLeft = MAX_CONTINUES;
    continuePromptUntilMs = 0;

    stagePlayStartMs = 0;
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    stage5Phase = 1;
    stage5EndedHandled = false;
    stage5Phase2At = null;
    stage5Phase3At = null;

    stopBgm();
    setStageArt(STAGES[0]);

    msgBox.innerHTML = "";
    pushMsg("READY");
    pushMsg("Fight (Start) → バフ選択 → ステージ開始", true);
    pushMsg(`Continues: ${MAX_CONTINUES}`, true);

    showOverlay(true);
    setOverlayText("READY", "Fight (Start) を選ぶ → バフ選択", "（クリックでもOK）");
    setInputsEnabled(false);
    updateUI();
  }

  function onBossDefeated(){
    if(gameState !== "playing") return;

    setInputsEnabled(false);
    hideBossBubble();
    pushMsg("✅ Boss defeated!");

    (async () => {
      const clearedStage = STAGES[stageIndex];
      const isFinal = (stageIndex === STAGES.length - 1);

      await showStageClearScreen(clearedStage);

      if(isFinal){
        onVictory();
      }else{
        stageIndex++;
        await startStage(stageIndex);
      }
    })();
  }

  function onVictory(){
    cleanupContinueListeners();
    gameState = "victory";
    setInputsEnabled(false);
    hideBossBubble();
    showStage5Timer(false);

    setBgm(AUDIO.victoryBgm, true);

    showOverlay(true);
    setOverlayText("VICTORY!", "5ステージクリア！Resetで再スタート（バフ選択から）", "（クリックでもOK）");
    pushMsg("🏆 VICTORY!");
  }

  async function cheatSkipToStage5(){
    if(!selectedBuff){
      pushMsg("CHEAT: バフが未選択 → 先にバフを選んでね", true);
      return;
    }
    if(stageIndex === 4){
      pushMsg("CHEAT: すでにStage 5です", true);
      return;
    }

    pushMsg("CHEAT: Stage 5へスキップ！", true);

    resetField();
    hideBossBubble();
    showStage5Timer(false);
    setStage5InvBanner(false);
    stage5InvShown = false;
    showOverlay(false);

    playerHp = clamp(playerHp, 1, playerMaxHp);
    updateUI();

    stageIndex = 4;
    await startStage(4);
  }

  function submitAnswer(){
    if(gameState !== "playing") return;

    const raw = answerInput.value.trim();
    answerInput.value = "";

    if(raw === CHEAT_SKIP_STAGE5){
      cheatSkipToStage5();
      return;
    }

    const ok = findMatchAndClear(raw);
    if(!ok){
      mistakes++;
      pushMsg(`MISS: ${raw || "(blank)"}`);
      damagePlayer(1, "input miss");
      updateUI();
    }

    answerInput.focus();
  }

  function tick(ts){
    if(!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    if(invulnActive && nowMs() >= invulnUntil){
      invulnActive = false;
      pushMsg("無敵終了", true);
      updateUI();
    }

    if(gameState === "continuePrompt"){
      updateContinueCountdownText();
      updateUI();
      requestAnimationFrame(tick);
      return;
    }

    if(gameState === "playing"){
      const stage = STAGES[stageIndex];
      const elapsed = stageElapsedSec();

      spawnAccMs += dt * 1000;
      let spawnMs = stage.spawnEveryMs;
      if(stageIndex === 4){
        spawnMs = stage5CurrentSpawnMs(elapsed);
      }

      let loops = 0;
      while(spawnAccMs >= spawnMs && loops < 6){
        spawnWord();
        spawnAccMs -= spawnMs;
        loops++;
      }

      const h = laneHeight();
      const fallSpeed = (stageIndex === 4)
        ? stage5CurrentFallSpeed(elapsed)
        : stage.fallSpeedPxPerSec;

      for(const w of wordsOnField){
        if(w.state !== "falling") continue;

        w.y += fallSpeed * dt;

        const landedCount = landedWords().length;
        const targetY = h - 30 * (landedCount + 1);

        if(w.y >= targetY){
          w.y = targetY;
          w.state = "landed";
          w.el.classList.add("landed");
          restackLanded();
        }
        w.el.style.top = `${w.y}px`;
      }

      overflow = landedWords().length >= laneCapacity();
      if(overflow){
        overflowAcc += dt;
        if(overflowAcc >= 1){
          const ticks = Math.floor(overflowAcc);
          overflowAcc -= ticks;
          damagePlayer(ticks, "overflow");
        }
      }else{
        overflowAcc = 0;
      }

      handleStage5PhaseTriggers();
      updateStage5Timer();
      updateUI();
    } else {
      updateStage5Timer();
      updateUI();
    }

    requestAnimationFrame(tick);
  }

  startCmd.addEventListener("click", () => {
    if(["playing","countdown","dialogue","stageclear","buffselect","continuePrompt"].includes(gameState)) return;
    startGame();
  });
  resetCmd.addEventListener("click", resetGame);
  runCmd.addEventListener("click", resetGame);

  answerForm.addEventListener("submit", (e) => {
    e.preventDefault();
    submitAnswer();
  });

  bgmVol.addEventListener("input", () => {
    const v = Number(bgmVol.value) / 100;
    isMuted = false;
    bgmMuteBtn.textContent = "MUTE";
    setBgmVolume(v);
  });
  bgmMuteBtn.addEventListener("click", toggleMute);

  document.documentElement.style.setProperty("--wordH", String(30));
  initSfxPool();
  setBgmVolume(0.35);
  resetGame();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
